using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

#pragma warning disable IDE0130
namespace System.Runtime.CompilerServices
#pragma warning restore IDE0130
{
    internal static class IsExternalInit;
}

namespace Unions.Pure.Csharp.SourceGenerator
{

    [Generator]
    public sealed class UnionsPureCsharpGenerator : IIncrementalGenerator
    {
        private const string AttributeNamespace = "Unions.Pure.Csharp";
        private const string AttributeName = "UnionMemberAttribute";
        private const string AttributeFullName = AttributeNamespace + "." + AttributeName;

        private const string InjectedAttributeSource = @"// <auto-generated/>
#nullable enable
using System;

namespace Unions.Pure.Csharp
{
    [Flags]
    public enum GenerateTarget
    {
        None = 0,
        IndirectLambdas = 1,
        Visitor = 2,
        TryOut = 4,
        JsonSerialization = 8,
        All = IndirectLambdas | Visitor | TryOut | JsonSerialization
    }

    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class UnionAttribute : Attribute
    {
        public GenerateTarget Targets { get; }

        public UnionAttribute()
        {
            Targets = GenerateTarget.All;
        }

        public UnionAttribute(params GenerateTarget[] targets)
        {
            if (targets is null || targets.Length == 0)
            {
                Targets = GenerateTarget.All;
                return;
            }

            GenerateTarget acc = GenerateTarget.None;
            for (int i = 0; i < targets.Length; i++)
                acc |= targets[i];

            Targets = acc;
        }
    }

    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
    public sealed class UnionMemberAttribute : Attribute
    {
        public string? Name { get; }

        public UnionMemberAttribute()
        {
            Name = null;
        }

        public UnionMemberAttribute(string name)
        {
            Name = name;
        }
    }

}
";

        public void Initialize(IncrementalGeneratorInitializationContext initContext)
        {
            // Don’t re-emit our helper types if they already come from a referenced assembly.
            initContext.RegisterSourceOutput(initContext.CompilationProvider, static (spc, compilation) =>
            {
                if (compilation.GetTypeByMetadataName(AttributeFullName) is null)
                    spc.AddSource("UnionMemberAttribute.g.cs", InjectedAttributeSource);
            });

            // Find type declarations that have attributes.
            var typeDeclsWithAttrs = initContext.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax t && t.AttributeLists.Count > 0,
                transform: static (ctx, _) => (TypeDeclarationSyntax)ctx.Node
            );

            // Track which candidates are partial.
            var unionTargets = typeDeclsWithAttrs.Select(static (tds, _) =>
            {
                // Keep a simple “is partial” flag.
                var isPartial = tds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
                return new Candidate(tds, isPartial);
            });

            var compilationAndTargets = initContext.CompilationProvider.Combine(unionTargets.Collect());

            initContext.RegisterSourceOutput(compilationAndTargets, static (spc, pair) =>
            {
                var (compilation, candidates) = pair;

                if (candidates.IsDefaultOrEmpty)
                    return;

                foreach (var cand in candidates)
                {
                    EmitIfAnnotated(spc, compilation, cand);
                }
            });
        }

        private static void EmitIfAnnotated(
            SourceProductionContext spc,
            Compilation compilation,
            Candidate cand)
        {
            var model = compilation.GetSemanticModel(cand.TypeDecl.SyntaxTree);
            if (model.GetDeclaredSymbol(cand.TypeDecl) is not INamedTypeSymbol typeSymbol)
                return;

            // Check if type is marked with [Union] attribute
            var unionAttrs = GetAttributesByShortName(cand.TypeDecl, "Union");
            if (unionAttrs.Length == 0)
                return; // not a union target - must have [Union] attribute

            // Extract members from properties only
            var (members, memberNames, propertySymbols) = ExtractMembers(model, typeSymbol, Array.Empty<AttributeSyntax>(), cand.TypeDecl);
            if (members.Length == 0)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "UNIONGEN006",
                        title: "Union must have properties with [UnionMember]",
                        messageFormat: "Type '{0}' has [Union] attribute but no properties with [UnionMember] attribute.",
                        category: "Unions.Pure.Csharp",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    cand.TypeDecl.GetLocation(),
                    typeSymbol.ToDisplayString()));
                return;
            }

            // Validate that properties are at least internal for serialization
            ValidatePropertyAccessibility(spc, propertySymbols);

            if (!cand.IsPartial)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "UNIONGEN001",
                        title: "Union target must be partial",
                        messageFormat: "Type '{0}' must be declared partial to use [UnionMember].",
                        category: "Unions.Pure.Csharp",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    cand.TypeDecl.GetLocation(),
                    typeSymbol.ToDisplayString()));
                return;
            }
            if (members.Length < 2)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "UNIONGEN002",
                        title: "Union must have at least two members",
                        messageFormat: "Type '{0}' has {1} [UnionMember] attribute(s). Provide at least two.",
                        category: "Unions.Pure.Csharp",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    cand.TypeDecl.GetLocation(),
                    typeSymbol.ToDisplayString(),
                    members.Length));
                return;
            }

            ValidateMemberNames(spc, typeSymbol, Array.Empty<AttributeSyntax>(), members, memberNames);

            var targets = ExtractGenerateTargets(model, unionAttrs);

            var source = GenerateUnionSource(typeSymbol, members, memberNames, targets);
            var hintName = MakeHintName(typeSymbol);
            spc.AddSource(hintName, source);
        }

        private static string GenerateUnionSource(
            INamedTypeSymbol typeSymbol,
            ITypeSymbol[] members,
            string?[] customNames,
            GenerateTarget targets)
        {
            var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : typeSymbol.ContainingNamespace.ToDisplayString();

            const string tagName = "UnionTag";

            var accessibility = typeSymbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                _ => "internal"
            };

            var isStruct = typeSymbol.TypeKind == TypeKind.Struct;
            var isReadonlyStruct = isStruct && typeSymbol.IsReadOnly;
            var isRecord = typeSymbol.IsRecord;

            var typeKind = isStruct ? "struct" : "class";

            var header = new StringBuilder();
            header.Append(accessibility).Append(' ');
            if (isReadonlyStruct) header.Append("readonly ");
            header.Append("partial ");
            if (isRecord) header.Append("record ");
            header.Append(typeKind).Append(' ').Append(typeSymbol.Name);
            if (typeSymbol.TypeParameters.Length > 0)
            {
                header.Append('<');
                for (int i = 0; i < typeSymbol.TypeParameters.Length; i++)
                {
                    if (i != 0) header.Append(", ");
                    header.Append(typeSymbol.TypeParameters[i].Name);
                }
                header.Append('>');
            }

            var sb = new StringBuilder(16_384);
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.");
            sb.AppendLine("#pragma warning disable CS8625 // Cannot convert null literal to non-nullable reference type.");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using System.Text.Json.Serialization;");
            sb.AppendLine();

            if (ns is not null)
            {
                sb.Append("namespace ").Append(ns).AppendLine(";");
                sb.AppendLine();
            }

            var tagIds = BuildTagIdentifiers(members, customNames);

            sb.AppendLine(header.ToString());
            sb.AppendLine("{");

            // Tag enum
            sb.AppendLine($"    public enum {tagName} : byte");
            sb.AppendLine("    {");
            for (int i = 0; i < members.Length; i++)
            {
                sb.Append("        ").Append(tagIds[i]).Append(" = ").Append(i + 1).AppendLine(",");
            }
            sb.AppendLine("    }");
            sb.AppendLine();

            // Tag property - computed from which property is non-null
            sb.AppendLine("    public ").Append(tagName).Append(" Tag");
            sb.AppendLine("    {");
            sb.AppendLine("        get");
            sb.AppendLine("        {");
            for (int i = 0; i < members.Length; i++)
            {
                var propName = tagIds[i];
                var tagValue = tagName + "." + tagIds[i];
                if (i == 0)
                {
                    sb.Append("            if (").Append(propName).Append(" != null) return ").Append(tagValue).AppendLine(";");
                }
                else
                {
                    sb.Append("            if (").Append(propName).Append(" != null) return ").Append(tagValue).AppendLine(";");
                }
            }
            sb.AppendLine("            return default;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();

            // Properties with [JsonInclude] are already declared by the user
            // We don't generate them - they're in the source code

            // Parameterless constructor for STJ deserialization
            sb.AppendLine("    public ").Append(typeSymbol.Name).AppendLine("()");
            sb.AppendLine("    {");
            sb.AppendLine("    }");
            sb.AppendLine();

            // Parameterized constructor - public for manual construction
            // Annotated with [JsonConstructor] so STJ uses it for deserialization
            sb.AppendLine("    [JsonConstructor]");
            sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("    public ").Append(typeSymbol.Name).Append("(");
            for (int i = 0; i < members.Length; i++)
            {
                var t = members[i];
                var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                // Use type as-is from property (already nullable if needed)
                if (i > 0) sb.Append(", ");
                sb.Append(typeName).Append(' ').Append(MakeParamIdentifier(tagIds[i]));
            }
            sb.AppendLine(")");
            sb.AppendLine("    {");
            for (int i = 0; i < members.Length; i++)
            {
                var propName = tagIds[i];
                var paramName = MakeParamIdentifier(tagIds[i]);
                sb.Append("        ").Append(propName).Append(" = ").Append(paramName).AppendLine(";");
            }
            sb.AppendLine("    }");
            sb.AppendLine();

            // FromX factories
            for (int i = 0; i < members.Length; i++)
            {
                var t = members[i];
                var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var tagIdent = tagIds[i];
                var propName = tagIds[i];
                var fromName = "From" + tagIdent;

                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append("    public static ").Append(typeSymbol.Name).Append(' ').Append(fromName)
                  .Append('(').Append(typeName).AppendLine(" value)");
                sb.Append("        => new(");
                for (int j = 0; j < members.Length; j++)
                {
                    if (j > 0) sb.Append(", ");
                    if (j == i) sb.Append("value");
                    else sb.Append("default");
                }
                sb.AppendLine(");");
                sb.AppendLine();
            }

            if ((targets & GenerateTarget.IndirectLambdas) != 0)
            {
                // Match<T>
                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append("    public T Match<T>(");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var onName = "on" + tagIds[i];
                    sb.Append("Func<").Append(typeName).Append(", T> ").Append(onName);
                    if (i != members.Length - 1) sb.Append(", ");
                }
                sb.AppendLine(")");
                sb.AppendLine("    {");

                for (int i = 0; i < members.Length; i++)
                {
                    var tagIdent = tagIds[i];
                    var propName = tagIds[i];
                    var onName = "on" + tagIdent;

                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.Append("            return ").Append(onName).Append("(").Append(propName).AppendLine("!);");
                    sb.AppendLine();
                }

                sb.AppendLine("        return ThrowUnknownTag<T>(Tag);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            if ((targets & GenerateTarget.TryOut) != 0)
            {
                // IsX / TryGetX helpers (inline, no delegates, no visitors)
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var tagIdent = tagIds[i];
                    var propName = tagIds[i];

                    sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.Append("    public bool Is").Append(tagIdent).Append("() => Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(";");
                    sb.AppendLine();

                    sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.Append("    public bool TryGet").Append(tagIdent).Append("(out ").Append(typeName).Append(" value)");
                    sb.AppendLine();
                    sb.AppendLine("    {");
                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.AppendLine("        {");
                    sb.Append("            value = ").Append(propName).AppendLine("!;");
                    sb.AppendLine("            return true;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine("        value = default!;");
                    sb.AppendLine("        return false;");
                    sb.AppendLine("    }");
                    sb.AppendLine();
                }
            }

            if ((targets & GenerateTarget.IndirectLambdas) != 0)
            {
                // Switch
                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append("    public void Switch(");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var onName = "on" + tagIds[i];
                    sb.Append("Action<").Append(typeName).Append("> ").Append(onName);
                    if (i != members.Length - 1) sb.Append(", ");
                }
                sb.AppendLine(")");
                sb.AppendLine("    {");

                for (int i = 0; i < members.Length; i++)
                {
                    var tagIdent = tagIds[i];
                    var propName = tagIds[i];
                    var onName = "on" + tagIdent;

                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.AppendLine("        {");
                    sb.Append("            ").Append(onName).Append("(").Append(propName).AppendLine("!);");
                    sb.AppendLine("            return;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }

                sb.AppendLine("        ThrowUnknownTag(Tag);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            if ((targets & GenerateTarget.Visitor) != 0)
            {
                // Visitor-based Match/Switch overloads (avoid delegates / enable inlining)
                sb.AppendLine("    public interface IMatchVisitor<TResult>");
                sb.AppendLine("    {");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var methodName = "On" + tagIds[i];
                    sb.Append("        TResult ").Append(methodName).Append('(').Append(typeName).AppendLine(" value);");
                }
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.AppendLine("    public interface ISwitchVisitor");
                sb.AppendLine("    {");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var methodName = "On" + tagIds[i];
                    sb.Append("        void ").Append(methodName).Append('(').Append(typeName).AppendLine(" value);");
                }
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine("    public TResult Match<TVisitor, TResult>(TVisitor visitor)");
                sb.AppendLine("        where TVisitor : struct, IMatchVisitor<TResult>");
                sb.AppendLine("    {");
                for (int i = 0; i < members.Length; i++)
                {
                    var tagIdent = tagIds[i];
                    var propName = tagIds[i];
                    var methodName = "On" + tagIdent;

                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.Append("            return visitor.").Append(methodName).Append("(").Append(propName).AppendLine("!);");
                    sb.AppendLine();
                }
                sb.AppendLine("        return ThrowUnknownTag<TResult>(Tag);");
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine("    public void Switch<TVisitor>(TVisitor visitor)");
                sb.AppendLine("        where TVisitor : struct, ISwitchVisitor");
                sb.AppendLine("    {");
                for (int i = 0; i < members.Length; i++)
                {
                    var tagIdent = tagIds[i];
                    var propName = tagIds[i];
                    var methodName = "On" + tagIdent;

                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.AppendLine("        {");
                    sb.Append("            visitor.").Append(methodName).Append("(").Append(propName).AppendLine("!);");
                    sb.AppendLine("            return;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }
                sb.AppendLine("        ThrowUnknownTag(Tag);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            // Throw helpers out-of-line
            sb.AppendLine("    [MethodImpl(MethodImplOptions.NoInlining)]");
            sb.AppendLine($"    private static T ThrowUnknownTag<T>({tagName} tag)");
            sb.AppendLine("        => throw new InvalidOperationException($\"Unknown tag: {tag}\");");
            sb.AppendLine();
            sb.AppendLine("    [MethodImpl(MethodImplOptions.NoInlining)]");
            sb.AppendLine($"    private static void ThrowUnknownTag({tagName} tag)");
            sb.AppendLine("        => throw new InvalidOperationException($\"Unknown tag: {tag}\");");

            sb.AppendLine("}");

            return sb.ToString();
        }


        private static string[] BuildTagIdentifiers(ITypeSymbol[] members, string?[] customNames)
        {
            var baseNames = new string[members.Length];
            var used = new HashSet<string>();

            for (int i = 0; i < members.Length; i++)
            {
                var custom = (customNames.Length == members.Length) ? customNames[i] : null;
                baseNames[i] = !string.IsNullOrWhiteSpace(custom) ? custom! : MakeTagIdentifier(members[i], i);
            }

            for (int i = 0; i < baseNames.Length; i++)
            {
                var candidate = baseNames[i];
                if (used.Add(candidate))
                    continue;

                // Disambiguate (keep the first one unchanged).
                var suffix = i + 1;
                var attempt = candidate + suffix.ToString();
                while (!used.Add(attempt))
                {
                    suffix++;
                    attempt = candidate + suffix.ToString();
                }
                baseNames[i] = attempt;
            }

            return baseNames;
        }

        private static (ITypeSymbol[] Members, string?[] Names, IPropertySymbol[] PropertySymbols) ExtractMembers(
            SemanticModel model,
            INamedTypeSymbol typeSymbol,
            AttributeSyntax[] unionMemberAttrs,
            TypeDeclarationSyntax typeDecl)
        {
            // First, try to extract from properties
            // Check all syntax references for partial types
            var propertyMembers = new List<ITypeSymbol>();
            var propertyNames = new List<string?>();
            var propertySymbols = new List<IPropertySymbol>();

            // Get all property symbols from the type
            foreach (var member in typeSymbol.GetMembers())
            {
                if (member is IPropertySymbol propSymbol)
                {
                    // Check all syntax references for this property (for partial types)
                    foreach (var syntaxRef in propSymbol.DeclaringSyntaxReferences)
                    {
                        var propSyntax = syntaxRef.GetSyntax() as PropertyDeclarationSyntax;
                        if (propSyntax != null)
                        {
                            var propAttrs = GetAttributesByShortName(propSyntax, "UnionMember");
                            if (propAttrs.Length > 0)
                            {
                                var propType = propSymbol.Type;
                                string? name = null;

                                // Extract name from attribute if provided
                                foreach (var attr in propAttrs)
                                {
                                    var args = attr.ArgumentList?.Arguments;
                                    if (args != null)
                                    {
                                        // Check for name parameter: [UnionMember(name: "X")] or [UnionMember("X")]
                                        if (args.Value.Count == 1)
                                        {
                                            if (TryGetStringArgument(model, args.Value[0].Expression, out var s) && s is not null)
                                            {
                                                name = s;
                                            }
                                        }
                                        else if (args.Value.Count == 2)
                                        {
                                            // Could be (Type, name) or (name, ...)
                                            if (TryGetStringArgument(model, args.Value[0].Expression, out var s1) && s1 is not null)
                                            {
                                                name = s1;
                                            }
                                            else if (TryGetStringArgument(model, args.Value[1].Expression, out var s2) && s2 is not null)
                                            {
                                                name = s2;
                                            }
                                        }
                                    }
                                }

                                // If no explicit name, use property name (sanitized)
                                if (name == null)
                                {
                                    name = FirstUpper(SanitizeIdentifier(propSymbol.Name));
                                }

                                propertyMembers.Add(propType);
                                propertyNames.Add(name);
                                propertySymbols.Add(propSymbol);
                                break; // Found this property, move to next
                            }
                        }
                    }
                }
            }

            // If we found property-based members, use those
            // Return property-based members
            return (propertyMembers.ToArray(), propertyNames.ToArray(), propertySymbols.ToArray());
        }

        [Flags]
        private enum GenerateTarget
        {
            None = 0,
            IndirectLambdas = 1,
            Visitor = 2,
            TryOut = 4,
            JsonSerialization = 8,
            All = IndirectLambdas | Visitor | TryOut | JsonSerialization
        }

        private static GenerateTarget ExtractGenerateTargets(SemanticModel model, AttributeSyntax[] attrs)
        {
            if (attrs.Length == 0)
                return GenerateTarget.All;

            // Multiple attrs: keep defaults.
            if (attrs.Length > 1)
                return GenerateTarget.All;

            var attr = attrs[0];
            var args = attr.ArgumentList?.Arguments;
            if (args is null || args.Value.Count == 0)
                return GenerateTarget.All;

            var acc = GenerateTarget.None;
            foreach (var a in args.Value)
            {
                if (TryParseGenerateTargetExpr(model, a.Expression, out var t))
                    acc |= t;
            }

            return acc == GenerateTarget.None ? GenerateTarget.All : acc;
        }

        private static void ValidatePropertyAccessibility(
            SourceProductionContext spc,
            IPropertySymbol[] propertySymbols)
        {
            foreach (var propSymbol in propertySymbols)
            {
                var accessibility = propSymbol.DeclaredAccessibility;
                // Properties must be at least internal for serialization to work
                if (accessibility != Accessibility.Public && accessibility != Accessibility.Internal)
                {
                    var location = propSymbol.Locations.FirstOrDefault();
                    spc.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "UNIONGEN008",
                            title: "UnionMember property must be at least internal",
                            messageFormat: "Property '{0}' marked with [UnionMember] must be at least internal (public or internal) for serialization to work.",
                            category: "Unions.Pure.Csharp",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        location ?? Location.None,
                        propSymbol.Name));
                }
            }
        }

        private static void ValidateMemberNames(
            SourceProductionContext spc,
            INamedTypeSymbol typeSymbol,
            AttributeSyntax[] unionMemberAttrs,
            ITypeSymbol[] members,
            string?[] names)
        {
            // If a member type appears more than once, all occurrences must have explicit, distinct names.
            // Also, if a name is provided, it must be convertible to a valid C# identifier, and overall names must be unique.
            var countsByType = new Dictionary<ITypeSymbol, int>(SymbolEqualityComparer.Default);
            for (int i = 0; i < members.Length; i++)
            {
                countsByType.TryGetValue(members[i], out var c);
                countsByType[members[i]] = c + 1;
            }

            var usedNames = new HashSet<string>(StringComparer.Ordinal);
            for (int i = 0; i < members.Length; i++)
            {
                var isDupType = countsByType[members[i]] > 1;
                var rawName = names[i];

                if (isDupType && string.IsNullOrWhiteSpace(rawName))
                {
                    spc.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "UNIONGEN003",
                            title: "Duplicate union member type requires a name",
                            messageFormat: "Type '{0}' has duplicate member type '{1}'. Provide a unique name: [UnionMember(typeof({1}), \"...\")].",
                            category: "Unions.Pure.Csharp",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        unionMemberAttrs[i].GetLocation() ?? typeSymbol.Locations.FirstOrDefault(),
                        typeSymbol.ToDisplayString(),
                        members[i].ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)));
                    continue;
                }

                if (!string.IsNullOrWhiteSpace(rawName))
                {
                    var sanitized = FirstUpper(SanitizeIdentifier(rawName!));
                    if (string.IsNullOrWhiteSpace(sanitized))
                    {
                        spc.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor(
                                id: "UNIONGEN004",
                                title: "Union member name is not a valid identifier",
                                messageFormat: "Type '{0}' has [UnionMember(..., \"{1}\")], but that cannot be converted into a valid C# identifier.",
                                category: "Unions.Pure.Csharp",
                                DiagnosticSeverity.Error,
                                isEnabledByDefault: true),
                            unionMemberAttrs[i].GetLocation() ?? typeSymbol.Locations.FirstOrDefault(),
                            typeSymbol.ToDisplayString(),
                            rawName));
                        continue;
                    }

                    names[i] = sanitized;
                    if (!usedNames.Add(sanitized))
                    {
                        spc.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor(
                                id: "UNIONGEN005",
                                title: "Union member names must be unique",
                                messageFormat: "Type '{0}' has duplicate union member name '{1}'. Names must be unique.",
                                category: "Unions.Pure.Csharp",
                                DiagnosticSeverity.Error,
                                isEnabledByDefault: true),
                            unionMemberAttrs[i].GetLocation() ?? typeSymbol.Locations.FirstOrDefault(),
                            typeSymbol.ToDisplayString(),
                            sanitized));
                    }
                }
            }
        }

        private static AttributeSyntax[] GetAttributesByShortName(TypeDeclarationSyntax typeDecl, string shortNameWithoutAttributeSuffix)
        {
            var result = new List<AttributeSyntax>();

            foreach (var list in typeDecl.AttributeLists)
            {
                foreach (var attr in list.Attributes)
                {
                    var rightmost = GetRightmostIdentifier(attr.Name);
                    if (rightmost is null)
                        continue;

                    if (string.Equals(rightmost, shortNameWithoutAttributeSuffix, StringComparison.Ordinal) ||
                        string.Equals(rightmost, shortNameWithoutAttributeSuffix + "Attribute", StringComparison.Ordinal))
                    {
                        result.Add(attr);
                    }
                }
            }

            return result.ToArray();
        }

        private static AttributeSyntax[] GetAttributesByShortName(PropertyDeclarationSyntax propDecl, string shortNameWithoutAttributeSuffix)
        {
            var result = new List<AttributeSyntax>();

            foreach (var list in propDecl.AttributeLists)
            {
                foreach (var attr in list.Attributes)
                {
                    var rightmost = GetRightmostIdentifier(attr.Name);
                    if (rightmost is null)
                        continue;

                    if (string.Equals(rightmost, shortNameWithoutAttributeSuffix, StringComparison.Ordinal) ||
                        string.Equals(rightmost, shortNameWithoutAttributeSuffix + "Attribute", StringComparison.Ordinal))
                    {
                        result.Add(attr);
                    }
                }
            }

            return result.ToArray();
        }

        private static string? GetRightmostIdentifier(NameSyntax name)
        {
            return name switch
            {
                IdentifierNameSyntax ins => ins.Identifier.ValueText,
                QualifiedNameSyntax qns => qns.Right.Identifier.ValueText,
                AliasQualifiedNameSyntax aqn => aqn.Name.Identifier.ValueText,
                GenericNameSyntax gns => gns.Identifier.ValueText,
                _ => null
            };
        }

        private static bool TryGetTypeOfArgument(SemanticModel model, ExpressionSyntax expr, out ITypeSymbol? type)
        {
            expr = Unwrap(expr);
            if (expr is TypeOfExpressionSyntax toe)
            {
                type = model.GetTypeInfo(toe.Type).Type;
                return type is not null;
            }

            type = null;
            return false;
        }

        private static bool TryGetStringArgument(SemanticModel model, ExpressionSyntax expr, out string? value)
        {
            expr = Unwrap(expr);
            if (model.GetConstantValue(expr) is { HasValue: true, Value: string s })
            {
                value = s;
                return true;
            }

            value = null;
            return false;
        }

        private static bool TryGetBoolArgument(SemanticModel model, ExpressionSyntax expr, out bool value)
        {
            expr = Unwrap(expr);
            if (model.GetConstantValue(expr) is { HasValue: true, Value: bool b })
            {
                value = b;
                return true;
            }

            value = default;
            return false;
        }

        private static ExpressionSyntax Unwrap(ExpressionSyntax expr)
        {
            while (expr is ParenthesizedExpressionSyntax p)
                expr = p.Expression;
            return expr;
        }

        private static bool TryParseGenerateTargetExpr(SemanticModel model, ExpressionSyntax expr, out GenerateTarget target)
        {
            expr = Unwrap(expr);

            if (expr is BinaryExpressionSyntax { OperatorToken.RawKind: (int)SyntaxKind.BarToken } bin)
            {
                if (!TryParseGenerateTargetExpr(model, bin.Left, out var left) ||
                    !TryParseGenerateTargetExpr(model, bin.Right, out var right))
                {
                    target = default;
                    return false;
                }

                target = left | right;
                return true;
            }

            if (expr is MemberAccessExpressionSyntax mae)
            {
                var name = mae.Name.Identifier.ValueText;
                return TryMapGenerateTargetName(name, out target);
            }

            if (expr is IdentifierNameSyntax ins)
            {
                var name = ins.Identifier.ValueText;
                return TryMapGenerateTargetName(name, out target);
            }

            // If this folds to a constant, just use it.
            var constant = model.GetConstantValue(expr);
            if (constant is { HasValue: true, Value: int i })
            {
                target = (GenerateTarget)i;
                return true;
            }

            target = default;
            return false;
        }

        private static bool TryMapGenerateTargetName(string name, out GenerateTarget target)
        {
            switch (name)
            {
                case nameof(GenerateTarget.None):
                    target = GenerateTarget.None;
                    return true;
                case nameof(GenerateTarget.IndirectLambdas):
                    target = GenerateTarget.IndirectLambdas;
                    return true;
                case nameof(GenerateTarget.Visitor):
                    target = GenerateTarget.Visitor;
                    return true;
                case nameof(GenerateTarget.TryOut):
                    target = GenerateTarget.TryOut;
                    return true;
                case "JsonSerialization":
                    target = (GenerateTarget)8; // JsonSerialization = 8
                    return true;
                case nameof(GenerateTarget.All):
                    target = GenerateTarget.All;
                    return true;
                default:
                    target = default;
                    return false;
            }
        }

        private static bool IsNullableValueType(ITypeSymbol t)
            => t is INamedTypeSymbol nts
               && nts.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

        private static string MakeTagIdentifier(ITypeSymbol t, int index)
        {
            // string => String; Foo.Bar => Bar; int => Int32; arrays => ElementArray
            string baseName = t switch
            {
                IArrayTypeSymbol ats => ats.ElementType.Name + "Array",
                INamedTypeSymbol nts when nts.SpecialType == SpecialType.System_String => "String",
                INamedTypeSymbol nts when nts.SpecialType != SpecialType.None => nts.Name,
                _ => t.Name
            };

            baseName = SanitizeIdentifier(baseName);
            if (string.IsNullOrWhiteSpace(baseName))
                baseName = "Member" + (index + 1);

            return FirstUpper(baseName);
        }

        private static string MakeFieldIdentifier(string tagIdent)
            => EscapeIdentifier("_" + FirstLower(tagIdent));

        private static string MakeParamIdentifier(string tagIdent)
            => EscapeIdentifier(FirstLower(tagIdent));

        private static string MakeHintName(INamedTypeSymbol typeSymbol)
        {
            var displayName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", string.Empty)
                .Replace("::", "_")
                .Replace(".", "_")
                .Replace("+", "_");

            var invalidChars = Path.GetInvalidFileNameChars();
            var sb = new StringBuilder(displayName.Length);
            foreach (var ch in displayName)
            {
                sb.Append(invalidChars.Contains(ch) ? '_' : ch);
            }

            return $"{sb}.Union.g.cs";
        }

        private static string SanitizeIdentifier(string s)
        {
            var sb = new StringBuilder(s.Length);
            foreach (var ch in s)
            {
                if (char.IsLetterOrDigit(ch) || ch == '_')
                    sb.Append(ch);
            }
            if (sb.Length == 0)
                return "Member";

            if (char.IsDigit(sb[0]))
                sb.Insert(0, '_');

            return sb.ToString();
        }

        private static string FirstUpper(string s)
            => string.IsNullOrEmpty(s) ? s : char.ToUpperInvariant(s[0]) + s.Substring(1);

        private static string FirstLower(string s)
            => string.IsNullOrEmpty(s) ? s : char.ToLowerInvariant(s[0]) + s.Substring(1);

        private static string EscapeIdentifier(string id)
        {
            if (string.IsNullOrWhiteSpace(id))
                return id;

            var keyword = SyntaxFacts.GetKeywordKind(id);
            var contextual = SyntaxFacts.GetContextualKeywordKind(id);
            if (keyword != SyntaxKind.None || contextual != SyntaxKind.None)
                return "@" + id;

            return id;
        }

        private readonly record struct Candidate(TypeDeclarationSyntax TypeDecl, bool IsPartial);
    }
}


