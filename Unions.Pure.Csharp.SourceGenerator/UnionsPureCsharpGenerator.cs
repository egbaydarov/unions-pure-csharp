using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

#pragma warning disable IDE0130
namespace System.Runtime.CompilerServices
#pragma warning restore IDE0130
{
    internal static class IsExternalInit;
}

namespace Unions.Pure.Csharp.SourceGenerator
{

    [Generator]
    public sealed class UnionsPureCsharpGenerator : IIncrementalGenerator
    {
        private const string AttributeNamespace = "Unions.Pure.Csharp";
        private const string AttributeName = "UnionMemberAttribute";
        private const string AttributeFullName = AttributeNamespace + "." + AttributeName;

        private const string InjectedAttributeSource = @"// <auto-generated/>
#nullable enable
using System;

namespace Unions.Pure.Csharp
{
    [Flags]
    public enum GenerateTarget
    {
        None = 0,
        IndirectLambdas = 1,
        Visitor = 2,
        TryOut = 4,
        // Json = 8, // legacy (replaced by [UnionSerializationContext])
        All = IndirectLambdas | Visitor | TryOut
    }

    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class UnionGeneratorAttribute : Attribute
    {
        public GenerateTarget Targets { get; }

        public UnionGeneratorAttribute(params GenerateTarget[] targets)
        {
            if (targets is null || targets.Length == 0)
            {
                Targets = GenerateTarget.All;
                return;
            }

            GenerateTarget acc = GenerateTarget.None;
            for (int i = 0; i < targets.Length; i++)
                acc |= targets[i];

            Targets = acc;
        }
    }

    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class UnionMemberAttribute : Attribute
    {
        public Type MemberType { get; }
        public string? Name { get; }

        public UnionMemberAttribute(Type memberType)
        {
            MemberType = memberType;
            Name = null;
        }

        public UnionMemberAttribute(Type memberType, string name)
        {
            MemberType = memberType;
            Name = name;
        }
    }

    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class UnionSerializationContextAttribute : Attribute
    {
        public Type ContextType { get; }
        public bool CaseInsensitivePropertyNameMatching { get; }

        public UnionSerializationContextAttribute(Type contextType)
        {
            ContextType = contextType;
            CaseInsensitivePropertyNameMatching = false;
        }

        public UnionSerializationContextAttribute(Type contextType, bool caseInsensitivePropertyNameMatching)
        {
            ContextType = contextType;
            CaseInsensitivePropertyNameMatching = caseInsensitivePropertyNameMatching;
        }
    }
}
";

        public void Initialize(IncrementalGeneratorInitializationContext initContext)
        {
            // Don’t re-emit our helper types if they already come from a referenced assembly.
            initContext.RegisterSourceOutput(initContext.CompilationProvider, static (spc, compilation) =>
            {
                if (compilation.GetTypeByMetadataName(AttributeFullName) is null)
                    spc.AddSource("UnionMemberAttribute.g.cs", InjectedAttributeSource);
            });

            // Find type declarations that have attributes.
            var typeDeclsWithAttrs = initContext.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax t && t.AttributeLists.Count > 0,
                transform: static (ctx, _) => (TypeDeclarationSyntax)ctx.Node
            );

            // Track which candidates are partial.
            var unionTargets = typeDeclsWithAttrs.Select(static (tds, _) =>
            {
                // Keep a simple “is partial” flag.
                var isPartial = tds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
                return new Candidate(tds, isPartial);
            });

            var compilationAndTargets = initContext.CompilationProvider.Combine(unionTargets.Collect());

            initContext.RegisterSourceOutput(compilationAndTargets, static (spc, pair) =>
            {
                var (compilation, candidates) = pair;

                if (candidates.IsDefaultOrEmpty)
                    return;

                foreach (var cand in candidates)
                {
                    EmitIfAnnotated(spc, compilation, cand);
                }
            });
        }

        private static void EmitIfAnnotated(
            SourceProductionContext spc,
            Compilation compilation,
            Candidate cand)
        {
            var model = compilation.GetSemanticModel(cand.TypeDecl.SyntaxTree);
            if (model.GetDeclaredSymbol(cand.TypeDecl) is not INamedTypeSymbol typeSymbol)
                return;

            var unionMemberAttrs = GetAttributesByShortName(cand.TypeDecl, "UnionMember");
            if (unionMemberAttrs.Length == 0)
                return; // not a union target

            if (!cand.IsPartial)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "UNIONGEN001",
                        title: "Union target must be partial",
                        messageFormat: "Type '{0}' must be declared partial to use [UnionMember].",
                        category: "Unions.Pure.Csharp",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    cand.TypeDecl.GetLocation(),
                    typeSymbol.ToDisplayString()));
                return;
            }

            var (members, memberNames) = ExtractMembers(model, unionMemberAttrs);
            if (members.Length < 2)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "UNIONGEN002",
                        title: "Union must have at least two members",
                        messageFormat: "Type '{0}' has {1} [UnionMember] attribute(s). Provide at least two.",
                        category: "Unions.Pure.Csharp",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    cand.TypeDecl.GetLocation(),
                    typeSymbol.ToDisplayString(),
                    members.Length));
                return;
            }

            ValidateMemberNames(spc, typeSymbol, unionMemberAttrs, members, memberNames);

            var unionGeneratorAttrs = GetAttributesByShortName(cand.TypeDecl, "UnionGenerator");
            var targets = ExtractGenerateTargets(model, unionGeneratorAttrs);

            var unionSerializationContextAttrs = GetAttributesByShortName(cand.TypeDecl, "UnionSerializationContext");
            var serializationContextType = ExtractSerializationContext(model, unionSerializationContextAttrs);

            var source = GenerateUnionSource(typeSymbol, members, memberNames, targets, serializationContextType?.ContextType, serializationContextType?.CaseInsensitivePropertyNameMatching ?? false);
            var hintName = MakeHintName(typeSymbol);
            spc.AddSource(hintName, source);
        }

        private static string GenerateUnionSource(
            INamedTypeSymbol typeSymbol,
            ITypeSymbol[] members,
            string?[] customNames,
            GenerateTarget targets,
            INamedTypeSymbol? serializationContextType,
            bool caseInsensitivePropertyNameMatching)
        {
            var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : typeSymbol.ContainingNamespace.ToDisplayString();

            const string tagName = "UnionTag";

            var accessibility = typeSymbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                _ => "internal"
            };

            var isStruct = typeSymbol.TypeKind == TypeKind.Struct;
            var isReadonlyStruct = isStruct && typeSymbol.IsReadOnly;
            var isRecord = typeSymbol.IsRecord;

            var typeKind = isStruct ? "struct" : "class";

            var header = new StringBuilder();
            header.Append(accessibility).Append(' ');
            if (isReadonlyStruct) header.Append("readonly ");
            header.Append("partial ");
            if (isRecord) header.Append("record ");
            header.Append(typeKind).Append(' ').Append(typeSymbol.Name);
            if (typeSymbol.TypeParameters.Length > 0)
            {
                header.Append('<');
                for (int i = 0; i < typeSymbol.TypeParameters.Length; i++)
                {
                    if (i != 0) header.Append(", ");
                    header.Append(typeSymbol.TypeParameters[i].Name);
                }
                header.Append('>');
            }

            var sb = new StringBuilder(16_384);
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            if (serializationContextType is not null)
            {
                sb.AppendLine("using System.Buffers;");
                sb.AppendLine("using System.Text.Json;");
            }
            sb.AppendLine();

            if (ns is not null)
            {
                sb.Append("namespace ").Append(ns).AppendLine(";");
                sb.AppendLine();
            }

            var tagIds = BuildTagIdentifiers(members, customNames);

            sb.AppendLine(header.ToString());
            sb.AppendLine("{");

            // Tag enum
            sb.AppendLine($"    public enum {tagName} : byte");
            sb.AppendLine("    {");
            for (int i = 0; i < members.Length; i++)
            {
                sb.Append("        ").Append(tagIds[i]).Append(" = ").Append(i + 1).AppendLine(",");
            }
            sb.AppendLine("    }");
            sb.AppendLine();

            // Tag field
            sb.AppendLine($"    public readonly {tagName} Tag;");

            // Fields
            for (int i = 0; i < members.Length; i++)
            {
                var t = members[i];
                var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var fieldName = MakeFieldIdentifier(tagIds[i]);

                var needsNullable = t.IsReferenceType || IsNullableValueType(t);
                sb.Append("    private readonly ").Append(typeName);
                if (needsNullable) sb.Append('?');
                sb.Append(' ').Append(fieldName).AppendLine(";");
            }
            sb.AppendLine();

            // ctor
            sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("    private ").Append(typeSymbol.Name).Append("(").Append(tagName).Append(" tag");
            for (int i = 0; i < members.Length; i++)
            {
                var t = members[i];
                var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var needsNullable = t.IsReferenceType || IsNullableValueType(t);
                sb.Append(", ").Append(typeName);
                if (needsNullable) sb.Append('?');
                sb.Append(' ').Append(MakeParamIdentifier(tagIds[i]));
            }
            sb.AppendLine(")");
            sb.AppendLine("    {");
            sb.AppendLine("        Tag = tag;");
            for (int i = 0; i < members.Length; i++)
            {
                var fieldName = MakeFieldIdentifier(tagIds[i]);
                sb.Append("        ").Append(fieldName)
                  .Append(" = ").Append(MakeParamIdentifier(tagIds[i])).AppendLine(";");
            }
            sb.AppendLine("    }");
            sb.AppendLine();

            // FromX factories
            for (int i = 0; i < members.Length; i++)
            {
                var t = members[i];
                var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var tagIdent = tagIds[i];
                var fromName = "From" + tagIdent;

                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append("    public static ").Append(typeSymbol.Name).Append(' ').Append(fromName)
                  .Append('(').Append(typeName).AppendLine(" value)");
                sb.Append("        => new(").Append(tagName).Append('.').Append(tagIdent);

                for (int j = 0; j < members.Length; j++)
                {
                    if (j == i) sb.Append(", value");
                    else sb.Append(", default");
                }
                sb.AppendLine(");");
                sb.AppendLine();
            }

            if ((targets & GenerateTarget.IndirectLambdas) != 0)
            {
                // Match<T>
                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append("    public T Match<T>(");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var onName = "on" + tagIds[i];
                    sb.Append("Func<").Append(typeName).Append(", T> ").Append(onName);
                    if (i != members.Length - 1) sb.Append(", ");
                }
                sb.AppendLine(")");
                sb.AppendLine("    {");

                for (int i = 0; i < members.Length; i++)
                {
                    var tagIdent = tagIds[i];
                    var fieldName = MakeFieldIdentifier(tagIds[i]);
                    var onName = "on" + tagIdent;

                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.Append("            return ").Append(onName).Append("(").Append(fieldName).AppendLine("!);");
                    sb.AppendLine();
                }

                sb.AppendLine("        return ThrowUnknownTag<T>(Tag);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            if ((targets & GenerateTarget.TryOut) != 0)
            {
                // IsX / TryGetX helpers (inline, no delegates, no visitors)
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var tagIdent = tagIds[i];
                    var fieldName = MakeFieldIdentifier(tagIds[i]);

                    sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.Append("    public bool Is").Append(tagIdent).Append("() => Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(";");
                    sb.AppendLine();

                    sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.Append("    public bool TryGet").Append(tagIdent).Append("(out ").Append(typeName).Append(" value)");
                    sb.AppendLine();
                    sb.AppendLine("    {");
                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.AppendLine("        {");
                    sb.Append("            value = ").Append(fieldName).AppendLine("!;");
                    sb.AppendLine("            return true;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine("        value = default!;");
                    sb.AppendLine("        return false;");
                    sb.AppendLine("    }");
                    sb.AppendLine();
                }
            }

            if ((targets & GenerateTarget.IndirectLambdas) != 0)
            {
                // Switch
                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append("    public void Switch(");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var onName = "on" + tagIds[i];
                    sb.Append("Action<").Append(typeName).Append("> ").Append(onName);
                    if (i != members.Length - 1) sb.Append(", ");
                }
                sb.AppendLine(")");
                sb.AppendLine("    {");

                for (int i = 0; i < members.Length; i++)
                {
                    var tagIdent = tagIds[i];
                    var fieldName = MakeFieldIdentifier(tagIds[i]);
                    var onName = "on" + tagIdent;

                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.AppendLine("        {");
                    sb.Append("            ").Append(onName).Append("(").Append(fieldName).AppendLine("!);");
                    sb.AppendLine("            return;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }

                sb.AppendLine("        ThrowUnknownTag(Tag);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            if ((targets & GenerateTarget.Visitor) != 0)
            {
                // Visitor-based Match/Switch overloads (avoid delegates / enable inlining)
                sb.AppendLine("    public interface IMatchVisitor<TResult>");
                sb.AppendLine("    {");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var methodName = "On" + tagIds[i];
                    sb.Append("        TResult ").Append(methodName).Append('(').Append(typeName).AppendLine(" value);");
                }
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.AppendLine("    public interface ISwitchVisitor");
                sb.AppendLine("    {");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var methodName = "On" + tagIds[i];
                    sb.Append("        void ").Append(methodName).Append('(').Append(typeName).AppendLine(" value);");
                }
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine("    public TResult Match<TVisitor, TResult>(TVisitor visitor)");
                sb.AppendLine("        where TVisitor : struct, IMatchVisitor<TResult>");
                sb.AppendLine("    {");
                for (int i = 0; i < members.Length; i++)
                {
                    var tagIdent = tagIds[i];
                    var fieldName = MakeFieldIdentifier(tagIds[i]);
                    var methodName = "On" + tagIdent;

                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.Append("            return visitor.").Append(methodName).Append("(").Append(fieldName).AppendLine("!);");
                    sb.AppendLine();
                }
                sb.AppendLine("        return ThrowUnknownTag<TResult>(Tag);");
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine("    public void Switch<TVisitor>(TVisitor visitor)");
                sb.AppendLine("        where TVisitor : struct, ISwitchVisitor");
                sb.AppendLine("    {");
                for (int i = 0; i < members.Length; i++)
                {
                    var tagIdent = tagIds[i];
                    var fieldName = MakeFieldIdentifier(tagIds[i]);
                    var methodName = "On" + tagIdent;

                    sb.Append("        if (Tag == ").Append(tagName).Append('.').Append(tagIdent).AppendLine(")");
                    sb.AppendLine("        {");
                    sb.Append("            visitor.").Append(methodName).Append("(").Append(fieldName).AppendLine("!);");
                    sb.AppendLine("            return;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }
                sb.AppendLine("        ThrowUnknownTag(Tag);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            // Throw helpers out-of-line
            sb.AppendLine("    [MethodImpl(MethodImplOptions.NoInlining)]");
            sb.AppendLine($"    private static T ThrowUnknownTag<T>({tagName} tag)");
            sb.AppendLine("        => throw new InvalidOperationException($\"Unknown tag: {tag}\");");
            sb.AppendLine();
            sb.AppendLine("    [MethodImpl(MethodImplOptions.NoInlining)]");
            sb.AppendLine($"    private static void ThrowUnknownTag({tagName} tag)");
            sb.AppendLine("        => throw new InvalidOperationException($\"Unknown tag: {tag}\");");

            if (serializationContextType is not null && typeSymbol.TypeParameters.Length == 0)
            {
                var ctxFqn = serializationContextType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var stringComparison = caseInsensitivePropertyNameMatching
                    ? "global::System.StringComparison.OrdinalIgnoreCase"
                    : "global::System.StringComparison.Ordinal";

                sb.AppendLine();
                sb.AppendLine("    private static string NameFor(global::System.Text.Json.JsonNamingPolicy? policy, string name)");
                sb.AppendLine("        => policy is null ? name : policy.ConvertName(name);");

                sb.AppendLine();
                sb.AppendLine("    public byte[] ToUtf8Bytes()");
                sb.AppendLine("    {");
                sb.AppendLine("        var ctx = " + ctxFqn + ".Default;");
                sb.AppendLine("        var policy = ctx.Options.PropertyNamingPolicy;");
                sb.AppendLine("        var buffer = new global::System.Buffers.ArrayBufferWriter<byte>();");
                sb.AppendLine("        using var writer = new global::System.Text.Json.Utf8JsonWriter(buffer);");
                sb.AppendLine("        writer.WriteStartObject();");
                sb.AppendLine("        switch (Tag)");
                sb.AppendLine("        {");
                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var tagIdent = tagIds[i];
                    var fieldName = MakeFieldIdentifier(tagIds[i]);
                    sb.AppendLine("            case " + tagName + "." + tagIdent + ":");
                    sb.AppendLine("                writer.WritePropertyName(NameFor(policy, \"" + tagIdent + "\"));");
                    sb.AppendLine("                global::System.Text.Json.JsonSerializer.Serialize<" + typeName + ">(writer, " + fieldName + "!, (global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<" + typeName + ">)ctx.GetTypeInfo(typeof(" + typeName + "))!);");
                    sb.AppendLine("                break;");
                }
                sb.AppendLine("            default: ThrowUnknownTag(Tag); break;");
                sb.AppendLine("        }");
                sb.AppendLine("        writer.WriteEndObject();");
                sb.AppendLine("        writer.Flush();");
                sb.AppendLine("        return buffer.WrittenSpan.ToArray();");
                sb.AppendLine("    }");

                sb.AppendLine();
                sb.AppendLine("    public global::System.ReadOnlySpan<byte> ToUtf8Span()");
                sb.AppendLine("        => ToUtf8Bytes();");

                sb.AppendLine();
                sb.AppendLine("    public global::System.ReadOnlyMemory<byte> ToUtf8Memory()");
                sb.AppendLine("        => ToUtf8Bytes();");

                sb.AppendLine();
                sb.AppendLine("    public static " + typeSymbol.Name + " FromUtf8Bytes(byte[] utf8Json)");
                sb.AppendLine("        => FromUtf8Bytes((global::System.ReadOnlySpan<byte>)utf8Json);");

                sb.AppendLine();
                sb.AppendLine("    public static " + typeSymbol.Name + " FromUtf8Bytes(global::System.ReadOnlySpan<byte> utf8Json)");
                sb.AppendLine("    {");
                sb.AppendLine("        var ctx = " + ctxFqn + ".Default;");
                sb.AppendLine("        var policy = ctx.Options.PropertyNamingPolicy;");
                sb.AppendLine("        var reader = new global::System.Text.Json.Utf8JsonReader(utf8Json, isFinalBlock: true, state: default);");
                sb.AppendLine("        if (!reader.Read() || reader.TokenType != global::System.Text.Json.JsonTokenType.StartObject)");
                sb.AppendLine("            throw new global::System.Text.Json.JsonException();");
                sb.AppendLine("        if (!reader.Read() || reader.TokenType != global::System.Text.Json.JsonTokenType.PropertyName)");
                sb.AppendLine("            throw new global::System.Text.Json.JsonException();");
                sb.AppendLine("        var prop = reader.GetString() ?? throw new global::System.Text.Json.JsonException();");
                sb.AppendLine("        if (!reader.Read()) throw new global::System.Text.Json.JsonException();");

                for (int i = 0; i < members.Length; i++)
                {
                    var t = members[i];
                    var typeName = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var tagIdent = tagIds[i];
                    var fromName = "From" + tagIdent;
                    sb.AppendLine("        {");
                    sb.AppendLine("            var n1 = \"" + tagIdent + "\";");
                    sb.AppendLine("            var n2 = NameFor(policy, \"" + tagIdent + "\");");
                    sb.AppendLine("            if (string.Equals(prop, n1, " + stringComparison + ") || string.Equals(prop, n2, " + stringComparison + "))");
                    sb.AppendLine("            {");
                    sb.AppendLine("                var ti = (global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<" + typeName + ">)ctx.GetTypeInfo(typeof(" + typeName + "))!;");
                    sb.AppendLine("                var v = global::System.Text.Json.JsonSerializer.Deserialize<" + typeName + ">(ref reader, ti);");
                    sb.AppendLine("                if (!reader.Read() || reader.TokenType != global::System.Text.Json.JsonTokenType.EndObject)");
                    sb.AppendLine("                    throw new global::System.Text.Json.JsonException();");
                    sb.AppendLine("                return " + fromName + "(v!);");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                }
                sb.AppendLine("        // Consume value for unknown property, then throw.");
                sb.AppendLine("        reader.Skip();");
                sb.AppendLine("        throw new global::System.Text.Json.JsonException($\"Unknown union member: {prop}\");");
                sb.AppendLine("    }");
            }

            sb.AppendLine("}");

            return sb.ToString();
        }

        private sealed record SerializationContextInfo(INamedTypeSymbol ContextType, bool CaseInsensitivePropertyNameMatching);

        private static SerializationContextInfo? ExtractSerializationContext(SemanticModel model, AttributeSyntax[] attrs)
        {
            if (attrs.Length == 0)
                return null;
            if (attrs.Length > 1)
                return null;

            var attr = attrs[0];
            var args = attr.ArgumentList?.Arguments;
            if (args is null || args.Value.Count is < 1 or > 2)
                return null;

            if (!TryGetTypeOfArgument(model, args.Value[0].Expression, out var typeArg) || typeArg is not INamedTypeSymbol nts)
                return null;

            var caseInsensitive = false;
            if (args.Value.Count == 2
                && TryGetBoolArgument(model, args.Value[1].Expression, out var b))
            {
                caseInsensitive = b;
            }

            return new SerializationContextInfo(nts, caseInsensitive);
        }

        private static string[] BuildTagIdentifiers(ITypeSymbol[] members, string?[] customNames)
        {
            var baseNames = new string[members.Length];
            var used = new HashSet<string>();

            for (int i = 0; i < members.Length; i++)
            {
                var custom = (customNames.Length == members.Length) ? customNames[i] : null;
                baseNames[i] = !string.IsNullOrWhiteSpace(custom) ? custom! : MakeTagIdentifier(members[i], i);
            }

            for (int i = 0; i < baseNames.Length; i++)
            {
                var candidate = baseNames[i];
                if (used.Add(candidate))
                    continue;

                // Disambiguate (keep the first one unchanged).
                var suffix = i + 1;
                var attempt = candidate + suffix.ToString();
                while (!used.Add(attempt))
                {
                    suffix++;
                    attempt = candidate + suffix.ToString();
                }
                baseNames[i] = attempt;
            }

            return baseNames;
        }

        private static (ITypeSymbol[] Members, string?[] Names) ExtractMembers(
            SemanticModel model,
            AttributeSyntax[] unionMemberAttrs)
        {
            var members = new List<ITypeSymbol>(unionMemberAttrs.Length);
            var names = new List<string?>(unionMemberAttrs.Length);

            foreach (var attr in unionMemberAttrs)
            {
                // ctor: (Type memberType) or (Type memberType, string name)
                var args = attr.ArgumentList?.Arguments;
                if (args is null || args.Value.Count is < 1 or > 2)
                    continue;

                if (!TryGetTypeOfArgument(model, args.Value[0].Expression, out var ts) || ts is null)
                    continue;

                string? name = null;
                if (args.Value.Count == 2
                    && TryGetStringArgument(model, args.Value[1].Expression, out var s) && s is not null)
                {
                    name = s;
                }

                members.Add(ts);
                names.Add(name);
            }

            return (members.ToArray(), names.ToArray());
        }

        [Flags]
        private enum GenerateTarget
        {
            None = 0,
            IndirectLambdas = 1,
            Visitor = 2,
            TryOut = 4,
            All = IndirectLambdas | Visitor | TryOut
        }

        private static GenerateTarget ExtractGenerateTargets(SemanticModel model, AttributeSyntax[] attrs)
        {
            if (attrs.Length == 0)
                return GenerateTarget.All;

            // Multiple attrs: keep defaults.
            if (attrs.Length > 1)
                return GenerateTarget.All;

            var attr = attrs[0];
            var args = attr.ArgumentList?.Arguments;
            if (args is null || args.Value.Count == 0)
                return GenerateTarget.All;

            var acc = GenerateTarget.None;
            foreach (var a in args.Value)
            {
                if (TryParseGenerateTargetExpr(model, a.Expression, out var t))
                    acc |= t;
            }

            return acc == GenerateTarget.None ? GenerateTarget.All : acc;
        }

        private static void ValidateMemberNames(
            SourceProductionContext spc,
            INamedTypeSymbol typeSymbol,
            AttributeSyntax[] unionMemberAttrs,
            ITypeSymbol[] members,
            string?[] names)
        {
            // If a member type appears more than once, all occurrences must have explicit, distinct names.
            // Also, if a name is provided, it must be convertible to a valid C# identifier, and overall names must be unique.
            var countsByType = new Dictionary<ITypeSymbol, int>(SymbolEqualityComparer.Default);
            for (int i = 0; i < members.Length; i++)
            {
                countsByType.TryGetValue(members[i], out var c);
                countsByType[members[i]] = c + 1;
            }

            var usedNames = new HashSet<string>(StringComparer.Ordinal);
            for (int i = 0; i < members.Length; i++)
            {
                var isDupType = countsByType[members[i]] > 1;
                var rawName = names[i];

                if (isDupType && string.IsNullOrWhiteSpace(rawName))
                {
                    spc.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "UNIONGEN003",
                            title: "Duplicate union member type requires a name",
                            messageFormat: "Type '{0}' has duplicate member type '{1}'. Provide a unique name: [UnionMember(typeof({1}), \"...\")].",
                            category: "Unions.Pure.Csharp",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        unionMemberAttrs[i].GetLocation() ?? typeSymbol.Locations.FirstOrDefault(),
                        typeSymbol.ToDisplayString(),
                        members[i].ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)));
                    continue;
                }

                if (!string.IsNullOrWhiteSpace(rawName))
                {
                    var sanitized = FirstUpper(SanitizeIdentifier(rawName!));
                    if (string.IsNullOrWhiteSpace(sanitized))
                    {
                        spc.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor(
                                id: "UNIONGEN004",
                                title: "Union member name is not a valid identifier",
                                messageFormat: "Type '{0}' has [UnionMember(..., \"{1}\")], but that cannot be converted into a valid C# identifier.",
                                category: "Unions.Pure.Csharp",
                                DiagnosticSeverity.Error,
                                isEnabledByDefault: true),
                            unionMemberAttrs[i].GetLocation() ?? typeSymbol.Locations.FirstOrDefault(),
                            typeSymbol.ToDisplayString(),
                            rawName));
                        continue;
                    }

                    names[i] = sanitized;
                    if (!usedNames.Add(sanitized))
                    {
                        spc.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor(
                                id: "UNIONGEN005",
                                title: "Union member names must be unique",
                                messageFormat: "Type '{0}' has duplicate union member name '{1}'. Names must be unique.",
                                category: "Unions.Pure.Csharp",
                                DiagnosticSeverity.Error,
                                isEnabledByDefault: true),
                            unionMemberAttrs[i].GetLocation() ?? typeSymbol.Locations.FirstOrDefault(),
                            typeSymbol.ToDisplayString(),
                            sanitized));
                    }
                }
            }
        }

        private static AttributeSyntax[] GetAttributesByShortName(TypeDeclarationSyntax typeDecl, string shortNameWithoutAttributeSuffix)
        {
            var result = new List<AttributeSyntax>();

            foreach (var list in typeDecl.AttributeLists)
            {
                foreach (var attr in list.Attributes)
                {
                    var rightmost = GetRightmostIdentifier(attr.Name);
                    if (rightmost is null)
                        continue;

                    if (string.Equals(rightmost, shortNameWithoutAttributeSuffix, StringComparison.Ordinal) ||
                        string.Equals(rightmost, shortNameWithoutAttributeSuffix + "Attribute", StringComparison.Ordinal))
                    {
                        result.Add(attr);
                    }
                }
            }

            return result.ToArray();
        }

        private static string? GetRightmostIdentifier(NameSyntax name)
        {
            return name switch
            {
                IdentifierNameSyntax ins => ins.Identifier.ValueText,
                QualifiedNameSyntax qns => qns.Right.Identifier.ValueText,
                AliasQualifiedNameSyntax aqn => aqn.Name.Identifier.ValueText,
                GenericNameSyntax gns => gns.Identifier.ValueText,
                _ => null
            };
        }

        private static bool TryGetTypeOfArgument(SemanticModel model, ExpressionSyntax expr, out ITypeSymbol? type)
        {
            expr = Unwrap(expr);
            if (expr is TypeOfExpressionSyntax toe)
            {
                type = model.GetTypeInfo(toe.Type).Type;
                return type is not null;
            }

            type = null;
            return false;
        }

        private static bool TryGetStringArgument(SemanticModel model, ExpressionSyntax expr, out string? value)
        {
            expr = Unwrap(expr);
            if (model.GetConstantValue(expr) is { HasValue: true, Value: string s })
            {
                value = s;
                return true;
            }

            value = null;
            return false;
        }

        private static bool TryGetBoolArgument(SemanticModel model, ExpressionSyntax expr, out bool value)
        {
            expr = Unwrap(expr);
            if (model.GetConstantValue(expr) is { HasValue: true, Value: bool b })
            {
                value = b;
                return true;
            }

            value = default;
            return false;
        }

        private static ExpressionSyntax Unwrap(ExpressionSyntax expr)
        {
            while (expr is ParenthesizedExpressionSyntax p)
                expr = p.Expression;
            return expr;
        }

        private static bool TryParseGenerateTargetExpr(SemanticModel model, ExpressionSyntax expr, out GenerateTarget target)
        {
            expr = Unwrap(expr);

            if (expr is BinaryExpressionSyntax { OperatorToken.RawKind: (int)SyntaxKind.BarToken } bin)
            {
                if (!TryParseGenerateTargetExpr(model, bin.Left, out var left) ||
                    !TryParseGenerateTargetExpr(model, bin.Right, out var right))
                {
                    target = default;
                    return false;
                }

                target = left | right;
                return true;
            }

            if (expr is MemberAccessExpressionSyntax mae)
            {
                var name = mae.Name.Identifier.ValueText;
                return TryMapGenerateTargetName(name, out target);
            }

            if (expr is IdentifierNameSyntax ins)
            {
                var name = ins.Identifier.ValueText;
                return TryMapGenerateTargetName(name, out target);
            }

            // If this folds to a constant, just use it.
            var constant = model.GetConstantValue(expr);
            if (constant is { HasValue: true, Value: int i })
            {
                target = (GenerateTarget)i;
                return true;
            }

            target = default;
            return false;
        }

        private static bool TryMapGenerateTargetName(string name, out GenerateTarget target)
        {
            switch (name)
            {
                case nameof(GenerateTarget.None):
                    target = GenerateTarget.None;
                    return true;
                case nameof(GenerateTarget.IndirectLambdas):
                    target = GenerateTarget.IndirectLambdas;
                    return true;
                case nameof(GenerateTarget.Visitor):
                    target = GenerateTarget.Visitor;
                    return true;
                case nameof(GenerateTarget.TryOut):
                    target = GenerateTarget.TryOut;
                    return true;
                case nameof(GenerateTarget.All):
                    target = GenerateTarget.All;
                    return true;
                default:
                    target = default;
                    return false;
            }
        }

        private static bool IsNullableValueType(ITypeSymbol t)
            => t is INamedTypeSymbol nts
               && nts.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

        private static string MakeTagIdentifier(ITypeSymbol t, int index)
        {
            // string => String; Foo.Bar => Bar; int => Int32; arrays => ElementArray
            string baseName = t switch
            {
                IArrayTypeSymbol ats => ats.ElementType.Name + "Array",
                INamedTypeSymbol nts when nts.SpecialType == SpecialType.System_String => "String",
                INamedTypeSymbol nts when nts.SpecialType != SpecialType.None => nts.Name,
                _ => t.Name
            };

            baseName = SanitizeIdentifier(baseName);
            if (string.IsNullOrWhiteSpace(baseName))
                baseName = "Member" + (index + 1);

            return FirstUpper(baseName);
        }

        private static string MakeFieldIdentifier(string tagIdent)
            => EscapeIdentifier("_" + FirstLower(tagIdent));

        private static string MakeParamIdentifier(string tagIdent)
            => EscapeIdentifier(FirstLower(tagIdent));

        private static string MakeHintName(INamedTypeSymbol typeSymbol)
        {
            var displayName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", string.Empty)
                .Replace("::", "_")
                .Replace(".", "_")
                .Replace("+", "_");

            var invalidChars = Path.GetInvalidFileNameChars();
            var sb = new StringBuilder(displayName.Length);
            foreach (var ch in displayName)
            {
                sb.Append(invalidChars.Contains(ch) ? '_' : ch);
            }

            return $"{sb}.Union.g.cs";
        }

        private static string SanitizeIdentifier(string s)
        {
            var sb = new StringBuilder(s.Length);
            foreach (var ch in s)
            {
                if (char.IsLetterOrDigit(ch) || ch == '_')
                    sb.Append(ch);
            }
            if (sb.Length == 0)
                return "Member";

            if (char.IsDigit(sb[0]))
                sb.Insert(0, '_');

            return sb.ToString();
        }

        private static string FirstUpper(string s)
            => string.IsNullOrEmpty(s) ? s : char.ToUpperInvariant(s[0]) + s.Substring(1);

        private static string FirstLower(string s)
            => string.IsNullOrEmpty(s) ? s : char.ToLowerInvariant(s[0]) + s.Substring(1);

        private static string EscapeIdentifier(string id)
        {
            if (string.IsNullOrWhiteSpace(id))
                return id;

            var keyword = SyntaxFacts.GetKeywordKind(id);
            var contextual = SyntaxFacts.GetContextualKeywordKind(id);
            if (keyword != SyntaxKind.None || contextual != SyntaxKind.None)
                return "@" + id;

            return id;
        }

        private readonly record struct Candidate(TypeDeclarationSyntax TypeDecl, bool IsPartial);
    }
}

